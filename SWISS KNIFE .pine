// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/

//@version=5
indicator("Swiss Knife",overlay = true)

ag = 3

donchian(len) =>
    math.avg(ta.lowest(len), ta.highest(len))
// Function to calculate indicators\
sumArray(arr) =>
    sum = 0.0
    if not(array.size(arr)>0)
        sum
    else
        for i = 0 to array.size(arr) - 1
            
            sum := sum + array.get(arr, i)
        sum

WeightedArraySum(values, weights) =>
    sum = 0.0
    // Check if both arrays are non-empty and have the same size
    if array.size(values) > 0 and array.size(weights) > 0 and array.size(values) == array.size(weights)
        for i = 0 to array.size(values) - 1
            sum := sum + array.get(values, i) * array.get(weights, i)
        // Normalize by the sum of weights
        sum / sumArray(weights)
    else
        1 // Return na if sizes are mismatched or arrays are empty
    
sliceArray(arr, start, stop) =>
    // Create a new empty float array to store the sliced elements
    newArray = array.new_float(0)
    
    // Ensure indices are within valid range
    startt = math.max(0, start)
    stopp = math.min(array.size(arr) - 1, stop)
    
    // Populate the new array with elements from the original array
    for i = startt to stopp
        array.push(newArray, array.get(arr, i))
    
    newArray  // Return the new sliced array

find_index(values,weights,start,stop)=>
    w_index = WeightedArraySum(sliceArray(values, start, stop),sliceArray(weights, start, stop))
    int(w_index)-1
getLastFractalValues(n) =>
    bool upflagDownFrontier = true
    bool upflagUpFrontier0 = true
    bool upflagUpFrontier1 = true
    bool upflagUpFrontier2 = true
    bool upflagUpFrontier3 = true
    bool upflagUpFrontier4 = true
    bool downflagDownFrontier = true
    bool downflagUpFrontier0 = true
    bool downflagUpFrontier1 = true
    bool downflagUpFrontier2 = true
    bool downflagUpFrontier3 = true
    bool downflagUpFrontier4 = true

    // UpFractal conditions
    for i = 1 to n
        upflagDownFrontier := upflagDownFrontier and (high[n-i] < high[n])
        upflagUpFrontier0 := upflagUpFrontier0 and (high[n+i] < high[n])
        upflagUpFrontier1 := upflagUpFrontier1 and (high[n+1] <= high[n] and high[n+i + 1] < high[n])
        upflagUpFrontier2 := upflagUpFrontier2 and (high[n+1] <= high[n] and high[n+2] <= high[n] and high[n+i + 2] < high[n])
        upflagUpFrontier3 := upflagUpFrontier3 and (high[n+1] <= high[n] and high[n+2] <= high[n] and high[n+3] <= high[n] and high[n+i + 3] < high[n])
        upflagUpFrontier4 := upflagUpFrontier4 and (high[n+1] <= high[n] and high[n+2] <= high[n] and high[n+3] <= high[n] and high[n+4] <= high[n] and high[n+i + 4] < high[n])

    flagUpFrontier = upflagUpFrontier0 or upflagUpFrontier1 or upflagUpFrontier2 or upflagUpFrontier3 or upflagUpFrontier4
    upFractal = (upflagDownFrontier and flagUpFrontier)

    // DownFractal conditions
    for i = 1 to n
        downflagDownFrontier := downflagDownFrontier and (low[n-i] > low[n])
        downflagUpFrontier0 := downflagUpFrontier0 and (low[n+i] > low[n])
        downflagUpFrontier1 := downflagUpFrontier1 and (low[n+1] >= low[n] and low[n+i + 1] > low[n])
        downflagUpFrontier2 := downflagUpFrontier2 and (low[n+1] >= low[n] and low[n+2] >= low[n] and low[n+i + 2] > low[n])
        downflagUpFrontier3 := downflagUpFrontier3 and (low[n+1] >= low[n] and low[n+2] >= low[n] and low[n+3] >= low[n] and low[n+i + 3] > low[n])
        downflagUpFrontier4 := downflagUpFrontier4 and (low[n+1] >= low[n] and low[n+2] >= low[n] and low[n+3] >= low[n] and low[n+4] >= low[n] and low[n+i + 4] > low[n])

    flagDownFrontier = downflagUpFrontier0 or downflagUpFrontier1 or downflagUpFrontier2 or downflagUpFrontier3 or downflagUpFrontier4
    downFractal = (downflagDownFrontier and flagDownFrontier)

    // Store last values if conditions met
    var float last_down_value = na
    var float last_up_value = na

    if downFractal
        last_down_value := close[n]
    if upFractal
        last_up_value := close[n]

    [last_down_value, last_up_value]//[upFractal,downFractal]//

basisType   = "SMMA"
basisLen    = 24
offsetSigma = 6
offsetALMA  = 0.85
delayOffset = 0

    // === /INPUTS ===
// Join our channel for more free tools: https://t.me/simpleforextools
    // Constants colours that include fully non-transparent option.


    // === BASE FUNCTIONS ===
    // Returns MA input selection variant, default to SMA if blank or typo.
variant(type, src, len, offSig, offALMA) =>
    v1 = ta.sma(src, len)                                                  // Simple
    v2 = ta.ema(src, len)                                                  // Exponential
    v3 = 2 * v2 - ta.ema(v2, len)                                          // Double Exponential
    v4 = 3 * (v2 - ta.ema(v2, len)) + ta.ema(ta.ema(v2, len), len)               // Triple Exponential
    v5 = ta.wma(src, len)                                                  // Weighted
    v6 = ta.vwma(src, len)                                                 // Volume Weighted
    v7 = 0.0
    v7 := na(v7[1]) ? ta.sma(src, len) : (v7[1] * (len - 1) + src) / len    // Smoothed
    v8 = ta.wma(2 * ta.wma(src, len / 2) - ta.wma(src, len), math.round(math.sqrt(len)))   // Hull
    v9 = ta.linreg(src, len, offSig)                                       // Least Squares
    v10 = ta.alma(src, len, offALMA, offSig)                               // Arnaud Legoux
    v11 = ta.sma(v1,len)                                                   // Triangular (extreme smooth)
    // SuperSmoother filter
    // © 2013  John F. Ehlers
    a1 = math.exp(-1.414*3.14159 / len)
    b1 = 2*a1*math.cos(1.414*3.14159 / len)
    c2 = b1
    c3 = (-a1)*a1
    c1 = 1 - c2 - c3
    v12 = 0.0
    v12 := c1*(src + nz(src[1])) / 2 + c2*nz(v12[1]) + c3*nz(v12[2])
    type=="EMA"?v2 : type=="DEMA"?v3 : type=="TEMA"?v4 : type=="WMA"?v5 : type=="VWMA"?v6 : type=="SMMA"?v7 : type=="HullMA"?v8 : type=="LSMA"?v9 : type=="ALMA"?v10 : type=="TMA"?v11: type=="SSMA"?v12: v1

screener_func(h, l, c, o) =>

    l1=3
    l2=5
    l3=7
    l4=11
    l5=13
    l6=17
    [upFractal1,downFractal1] = getLastFractalValues(l1)
    [upFractal2,downFractal2] = getLastFractalValues(l2)
    [upFractal3,downFractal3] = getLastFractalValues(l3)
    [upFractal4,downFractal4] = getLastFractalValues(l4)
    [upFractal5,downFractal5] = getLastFractalValues(l5)
    [upFractal6,downFractal6] = getLastFractalValues(l6)
    upval = c*6-(upFractal1[1]+upFractal2[1]+upFractal3[1]+upFractal4[1]+upFractal5[1]+upFractal6[1])
    downval = (downFractal1[1]+downFractal2[1]+downFractal3[1]+downFractal4[1]+downFractal5[1]+downFractal6[1])-c*6
    mtCond = (upval-downval)>0




    


    upper_wick = close>open ? high-close : high-open
    lower_wick = close>open ? open-low : close-low
    spread = high-low
    body_length = spread - (upper_wick + lower_wick)

    percent_upper_wick = upper_wick/spread
    percent_lower_wick = lower_wick/spread
    percent_body_length = body_length/spread


    buying_volume = close>open ? (percent_body_length + (percent_upper_wick + percent_lower_wick)/2)*volume : ((percent_upper_wick + percent_lower_wick)/2) * volume
    selling_volume = close<open ? (percent_body_length + (percent_upper_wick + percent_lower_wick)/2)*volume : ((percent_upper_wick + percent_lower_wick)/2) * volume



    volume_signal1 = 100*(buying_volume-selling_volume)/volume

    cc = 0

    fast_length1 = 120
    slow_length1 = 260
    src1 = volume_signal1
    signal_length1 = 90

    // Calculating
    fast_ma1 =variant('SMMA', src1[delayOffset], fast_length1, offsetSigma, offsetALMA)
    slow_ma1 = variant('SMMA', src1[delayOffset], slow_length1, offsetSigma, offsetALMA)
    macd1 = fast_ma1 - slow_ma1
    signal1 = variant('SMMA', macd1[delayOffset], signal_length1, offsetSigma, offsetALMA)

    hist1 = macd1 - signal1
    vmCond = hist1>0


    cumulative_buying_volume = ta.cum(buying_volume)
    cumulative_selling_volume = ta.cum(selling_volume)
    src = 100*(cumulative_buying_volume-cumulative_selling_volume)/((cumulative_buying_volume+cumulative_selling_volume)/2)
    fast_ma =variant('SMMA', src[delayOffset], 12, offsetSigma, offsetALMA)
    slow_ma = variant('SMMA', src[delayOffset], 26, offsetSigma, offsetALMA)
    macd = fast_ma - slow_ma
    signal = variant('SMMA', macd[delayOffset], 9, offsetSigma, offsetALMA)

    hist = macd - signal
    cvmCond = hist>0

    var lowerTimeframe = switch
        timeframe.isseconds     => "1S"
        timeframe.isintraday    => "1"
        timeframe.isdaily       => "10"
        => "60"


    inp_num_bins =      250
    inp_type = 'Volume'

    // -----------------------------------------------------------------------------

    [intrabar_highs, intrabar_lows, intrabar_vol] = request.security_lower_tf(syminfo.tickerid, lowerTimeframe, [high, low, volume])



    float intrabar_poc = na

    // -----------------------------------------------------------------------------

    size = array.size(intrabar_highs)

    if size > 0

        float[] tpo_bins = array.new_float()

        for i = 0 to inp_num_bins - 1
            array.push(tpo_bins, 0)

        inc = (high - low) / inp_num_bins
        num_vals = array.size(intrabar_highs)
        for i = 0 to inp_num_bins - 1
            bin_bottom = low + i * inc
            bin_top = bin_bottom + inc

            for j = 0 to num_vals - 1
                intrabar_high = array.get(intrabar_highs, j)
                intrabar_low = array.get(intrabar_lows, j)
                intrabar_volume = inp_type == "Time" ? 1 : array.get(intrabar_vol, j)
                
                inside_bin = intrabar_high <= bin_top and intrabar_low >= bin_bottom
                spans_bin = intrabar_high > bin_top and intrabar_low < bin_bottom
                up_bin = intrabar_high > bin_bottom and intrabar_high < bin_top and intrabar_low < bin_bottom
                dn_bin = intrabar_low < bin_top and intrabar_low > bin_bottom and intrabar_high > bin_top
                
                if inside_bin
                    current = array.get(tpo_bins, i)
                    array.set(tpo_bins, i, current + (1 * intrabar_volume))
                else if spans_bin
                    current = array.get(tpo_bins, i)
                    val = (bin_top - bin_bottom) / (intrabar_high - intrabar_low) * intrabar_volume
                    array.set(tpo_bins, i, current + val)
                else if up_bin
                    current = array.get(tpo_bins, i)
                    val = (intrabar_high - bin_bottom) / (intrabar_high - intrabar_low) * intrabar_volume
                    array.set(tpo_bins, i, current + val)
                else if dn_bin
                    current = array.get(tpo_bins, i)
                    val = (bin_top - intrabar_low) / (intrabar_high - intrabar_low) * intrabar_volume
                    array.set(tpo_bins, i, current + val)
        
        poc_val = array.max(tpo_bins)
        poc_index = array.indexof(tpo_bins, poc_val)
        
        intrabar_poc := low + inc * (poc_index + 0.5)
        floatArray = array.new_float(array.size(tpo_bins))

        // Populate the array with values from 0 to n
        for i = 0 to array.size(tpo_bins)-1
            array.set(floatArray, i, i)
        cc = find_index(floatArray,tpo_bins,0,array.size(tpo_bins)-1)



    src2 = ta.wma(close,100)-ta.wma(cc,100)

    fast_ma2 =variant('SMMA', src2[delayOffset], 12, offsetSigma, offsetALMA)
    slow_ma2 = variant('SMMA', src2[delayOffset], 26, offsetSigma, offsetALMA)
    macd2= fast_ma - slow_ma
    signal2 = variant('SMMA', macd2[delayOffset], 9, offsetSigma, offsetALMA)

    hist2 = macd2 - signal2
    pocCond = hist2>0
    // Existing indicators
    [macdLine, signalLine, histLine] = ta.macd(c, 12, 26, 9)
    macdC = histLine > 0
    hl22 = (h + l) / 2
    ao = ta.sma(hl22, 5) - ta.sma(hl22, 34)
    aoC = ao > 0
    sar = ta.sar(0.02, 0.02, 0.2)
    sarC = sar < c
    [supertrend, direction] = ta.supertrend(3, 10)
    supertrendC = direction > 0
    period_ = 21
    isCentered = false
    barsback = period_ / 2 + 1
    ma = ta.sma(c, period_)
    dpo = isCentered ? c[barsback] - ma : c - ma[barsback]
    dpoC = dpo > 0

    // Additional Indicators
    rsi = ta.rsi(c, 14)
    rsiC = rsi > 50

    source = close
    lengthRSI = 14
    lengthStoch = 7
    smoothK = 3
    smoothD = 3
    rsi1 = ta.rsi(source, lengthRSI)
    k = ta.sma(ta.stoch(rsi1, rsi1, rsi1, lengthStoch), smoothK)
    d = ta.sma(k, smoothD)
    stochC = k>50

    [basis, upper, lower] = ta.bb(c, 20, 2)
    bbC = c>basis

    conversionPeriods = 9
    basePeriods = 26
    laggingSpan2Periods = 52
    displacement = 26

    // Function to calculate Donchian Channel
    


// Join our channel for more free tools: https://t.me/simpleforextools


    // Calculate Ichimoku Lines
    conversionLine = donchian(conversionPeriods)
    baseLine = donchian(basePeriods)
    leadLine1 = math.avg(conversionLine, baseLine)
    leadLine2 = donchian(laggingSpan2Periods)

    // Define conditions for Ichimoku
    ichimokuBullish = conversionLine > baseLine and close > leadLine1 and close > leadLine2
    ichimokuBearish = conversionLine < baseLine and close < leadLine1 and close < leadLine2

    // Set the color condition
    ichimokuC = ichimokuBullish ? true : ichimokuBearish ? false : na

    cmo = ta.cmo(c, 14)
    cmoC = cmo > 50 ? true : cmo < -50 ? false : na

    donchianUpper = ta.highest(h, 20)
    donchianLower = ta.lowest(l, 20)
    donchianC = c > donchianUpper ? true : c < donchianLower ? false : na
    len = 14
    th = 20

    TrueRange = math.max(math.max(high-low, math.abs(high-nz(close[1]))), math.abs(low-nz(close[1])))
    DirectionalMovementPlus = high-nz(high[1]) > nz(low[1])-low ? math.max(high-nz(high[1]), 0): 0
    DirectionalMovementMinus = nz(low[1])-low > high-nz(high[1]) ? math.max(nz(low[1])-low, 0): 0


    SmoothedTrueRange = 0.0
    SmoothedTrueRange := nz(SmoothedTrueRange[1]) - (nz(SmoothedTrueRange[1])/len) + TrueRange

    SmoothedDirectionalMovementPlus = 0.0
    SmoothedDirectionalMovementPlus := nz(SmoothedDirectionalMovementPlus[1]) - (nz(SmoothedDirectionalMovementPlus[1])/len) + DirectionalMovementPlus

    SmoothedDirectionalMovementMinus = 0.0
    SmoothedDirectionalMovementMinus := nz(SmoothedDirectionalMovementMinus[1]) - (nz(SmoothedDirectionalMovementMinus[1])/len) + DirectionalMovementMinus

    DIPlus = SmoothedDirectionalMovementPlus / SmoothedTrueRange * 100
    DIMinus = SmoothedDirectionalMovementMinus / SmoothedTrueRange * 100
    adxC = DIPlus > DIMinus ? true :DIPlus < DIMinus ? false : na
    [macdC, aoC, sarC, supertrendC, dpoC, rsiC, stochC, bbC, ichimokuC, cmoC, donchianC, adxC,mtCond,vmCond,pocCond,cvmCond]

// Retrieve indicator values for multiple timeframes
[macdC_d, aoC_d, sarC_d, supertrendC_d, dpoC_d, rsiC_d, stochC_d, bbC_d, ichimokuC_d, cmoC_d, donchianC_d, adxC_d,mtCond_d,vmCond_d,pocCond_d,cvmCond_d] = request.security(syminfo.tickerid, "D", screener_func(high, low, close, open))
[macdC_4h, aoC_4h, sarC_4h, supertrendC_4h, dpoC_4h, rsiC_4h, stochC_4h, bbC_4h, ichimokuC_4h, cmoC_4h, donchianC_4h, adxC_4h,mtCond_4h,vmCond_4h,pocCond_4h,cvmCond_4h] = request.security(syminfo.tickerid, "240", screener_func(high, low, close, open))
[macdC_1h, aoC_1h, sarC_1h, supertrendC_1h, dpoC_1h, rsiC_1h, stochC_1h, bbC_1h, ichimokuC_1h, cmoC_1h, donchianC_1h, adxC_1h,mtCond_1h,vmCond_1h,pocCond_1h,cvmCond_1h] = request.security(syminfo.tickerid, "60", screener_func(high, low, close, open))
[macdC_15m, aoC_15m, sarC_15m, supertrendC_15m, dpoC_15m, rsiC_15m, stochC_15m, bbC_15m, ichimokuC_15m, cmoC_15m, donchianC_15m, adxC_15m,mtCond_15m,vmCond_15m,pocCond_15m,cvmCond_15m] = request.security(syminfo.tickerid, "15", screener_func(high, low, close, open))
dc = (macdC_d?1:-1) + (aoC_d?1:-1) + (supertrendC_d?1:-1) + (dpoC_d?1:-1) +(rsiC_d?1:-1) + (stochC_d?1:-1) + (bbC_d?1:-1) + (ichimokuC_d?1:-1) +( cmoC_d?1:-1) + (donchianC_d?1:-1) + (adxC_d?1:-1)     + (cvmCond_d?1:-1) +( pocCond_d?1:-1) + (vmCond_d?1:-1) + (mtCond_d?1:-1)
d4h = (macdC_4h?1:-1 )+ (aoC_4h?1:-1 )+ (supertrendC_4h?1:-1 )+ (dpoC_4h?1:-1) +(rsiC_4h?1:-1 )+ (stochC_4h?1:-1) + (bbC_4h?1:-1) + (ichimokuC_4h?1:-1) + (cmoC_4h?1:-1) + (donchianC_4h?1:-1) + (adxC_4h?1:-1) + (cvmCond_4h?1:-1) +( pocCond_4h?1:-1) + (vmCond_4h?1:-1) + (mtCond_4h?1:-1)
d1h = (macdC_1h?1:-1) + (aoC_1h?1:-1) + (supertrendC_1h?1:-1) +( dpoC_1h?1:-1) +(rsiC_1h?1:-1 )+ (stochC_1h?1:-1) + (bbC_1h?1:-1 )+ (ichimokuC_1h?1:-1) + (cmoC_1h?1:-1) + (donchianC_1h?1:-1) + (adxC_1h?1:-1) + (cvmCond_1h?1:-1) +( pocCond_1h?1:-1) + (vmCond_1h?1:-1) + (mtCond_1h?1:-1)
d15m = (macdC_15m?1:-1) + (aoC_15m?1:-1 )+ (supertrendC_15m?1:-1) + (dpoC_d?1:-1 )+(rsiC_15m?1:-1) +( stochC_15m?1:-1) +( bbC_15m?1:-1) + (ichimokuC_15m?1:-1) + (cmoC_15m?1:-1) + (donchianC_15m?1:-1) + (adxC_15m?1:-1) + (cvmCond_15m?1:-1) +( pocCond_15m?1:-1) + (vmCond_15m?1:-1) + (mtCond_15m?1:-1)


// Create table
var tbl = table.new(position.middle_right, 5, 18, frame_color = #151715, frame_width = 1, border_width = 2, border_color = color.new(color.white, 100))

if barstate.islast
    // Daily
    table.cell(tbl, 1, 0, "Daily", text_halign = text.align_center, bgcolor = na,text_color = color.white)
    table.cell(tbl, 1, 1, "MACD", text_halign = text.align_center, bgcolor = macdC_d ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 1, 2, "AO", text_halign = text.align_center, bgcolor = aoC_d ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 1, 3, "SAR", text_halign = text.align_center, bgcolor = sarC_d ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 1, 4, "SuperTrend", text_halign = text.align_center, bgcolor = supertrendC_d ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 1, 5, "DPO", text_halign = text.align_center, bgcolor = dpoC_d ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 1, 6, "RSI", text_halign = text.align_center, bgcolor = rsiC_d ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 1, 7, "Stochastic", text_halign = text.align_center, bgcolor = stochC_d ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 1, 8, "BB", text_halign = text.align_center, bgcolor = bbC_d ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 1, 9, "Ichimoku", text_halign = text.align_center, bgcolor = ichimokuC_d ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 1, 10, "Chande", text_halign = text.align_center, bgcolor = cmoC_d ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 1, 11, "Donchian", text_halign = text.align_center, bgcolor = donchianC_d ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 1, 12, "ADX", text_halign = text.align_center, bgcolor = adxC_d ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 1, 13, "VolMom", text_halign = text.align_center, bgcolor = vmCond_d ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 1, 14, "CumVolMom", text_halign = text.align_center, bgcolor = cvmCond_d ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 1, 15, "POCMom", text_halign = text.align_center, bgcolor = pocCond_d ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 1, 16, "Fractals", text_halign = text.align_center, bgcolor = mtCond_d ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 1, 17, str.tostring(100*(math.round(((dc/17)+1)/2,2)))+'/100', text_halign = text.align_center, bgcolor = dc>0 ? color.green : color.red, text_color = color.black, text_size = size.small)

    // Repeat for 4-hour, 1-hour, and 15-min timeframes
    // 4-hour
    table.cell(tbl, 2, 0, "4-Hour", text_halign = text.align_center, bgcolor = na,text_color = color.white)
    table.cell(tbl, 2, 1, "MACD", text_halign = text.align_center, bgcolor = macdC_4h ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 2, 2, "AO", text_halign = text.align_center, bgcolor = aoC_4h ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 2, 3, "SAR", text_halign = text.align_center, bgcolor = sarC_4h ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 2, 4, "SuperTrend", text_halign = text.align_center, bgcolor = supertrendC_4h ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 2, 5, "DPO", text_halign = text.align_center, bgcolor = dpoC_4h ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 2, 6, "RSI", text_halign = text.align_center, bgcolor = rsiC_4h ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 2, 7, "Stochastic", text_halign = text.align_center, bgcolor = stochC_4h ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 2, 8, "BB", text_halign = text.align_center, bgcolor = bbC_4h ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 2, 9, "Ichimoku", text_halign = text.align_center, bgcolor = ichimokuC_4h ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 2, 10, "Chande", text_halign = text.align_center, bgcolor = cmoC_4h ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 2, 11, "Donchian", text_halign = text.align_center, bgcolor = donchianC_4h ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 2, 12, "ADX", text_halign = text.align_center, bgcolor = adxC_4h ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 2, 13, "VolMom", text_halign = text.align_center, bgcolor = vmCond_4h ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 2, 14, "CumVolMom", text_halign = text.align_center, bgcolor = cvmCond_4h ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 2, 15, "POCMom", text_halign = text.align_center, bgcolor = pocCond_4h ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 2, 16, "Fractals", text_halign = text.align_center, bgcolor = mtCond_4h ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 2, 17, str.tostring(100*(math.round(((d4h/17)+1)/2,2)))+'/100', text_halign = text.align_center, bgcolor = d4h>0 ? color.green : color.red, text_color = color.black, text_size = size.small)

   // 1-hour
    table.cell(tbl, 3, 0, "1-Hour", text_halign = text.align_center, bgcolor = na,text_color = color.white)
    table.cell(tbl, 3, 1, "MACD", text_halign = text.align_center, bgcolor = macdC_1h ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 3, 2, "AO", text_halign = text.align_center, bgcolor = aoC_1h ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 3, 3, "SAR", text_halign = text.align_center, bgcolor = sarC_1h ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 3, 4, "SuperTrend", text_halign = text.align_center, bgcolor = supertrendC_1h ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 3, 5, "DPO", text_halign = text.align_center, bgcolor = dpoC_1h ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 3, 6, "RSI", text_halign = text.align_center, bgcolor = rsiC_1h ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 3, 7, "Stochastic", text_halign = text.align_center, bgcolor = stochC_1h ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 3, 8, "BB", text_halign = text.align_center, bgcolor = bbC_1h ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 3, 9, "Ichimoku", text_halign = text.align_center, bgcolor = ichimokuC_1h ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 3, 10, "Chande", text_halign = text.align_center, bgcolor = cmoC_1h ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 3, 11, "Donchian", text_halign = text.align_center, bgcolor = donchianC_1h ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 3, 12, "ADX", text_halign = text.align_center, bgcolor = adxC_1h ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 3, 13, "VolMom", text_halign = text.align_center, bgcolor = vmCond_1h ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 3, 14, "CumVolMom", text_halign = text.align_center, bgcolor = cvmCond_1h ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 3, 15, "POCMom", text_halign = text.align_center, bgcolor = pocCond_1h ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 3, 16, "Fractals", text_halign = text.align_center, bgcolor = mtCond_1h ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 3, 17, str.tostring(100*(math.round(((d1h/17)+1)/2,2)))+'/100', text_halign = text.align_center, bgcolor = d1h>0 ? color.green : color.red, text_color = color.black, text_size = size.small)

    // 15 minutes
    table.cell(tbl, 4, 0, "15-Min", text_halign = text.align_center, bgcolor = na,text_color = color.white)
    table.cell(tbl, 4, 1, "MACD", text_halign = text.align_center, bgcolor = macdC_15m ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 4, 2, "AO", text_halign = text.align_center, bgcolor = aoC_15m ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 4, 3, "SAR", text_halign = text.align_center, bgcolor = sarC_15m ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 4, 4, "SuperTrend", text_halign = text.align_center, bgcolor = supertrendC_15m ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 4, 5, "DPO", text_halign = text.align_center, bgcolor = dpoC_15m ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 4, 6, "RSI", text_halign = text.align_center, bgcolor = rsiC_15m ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 4, 7, "Stochastic", text_halign = text.align_center, bgcolor = stochC_15m ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 4, 8, "BB", text_halign = text.align_center, bgcolor = bbC_15m ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 4, 9, "Ichimoku", text_halign = text.align_center, bgcolor = ichimokuC_15m ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 4, 10, "Chande", text_halign = text.align_center, bgcolor = cmoC_15m ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 4, 11, "Donchian", text_halign = text.align_center, bgcolor = donchianC_15m ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 4, 12, "ADX", text_halign = text.align_center, bgcolor = adxC_15m ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 4, 13, "VolMom", text_halign = text.align_center, bgcolor = vmCond_15m ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 4, 14, "CumVolMom", text_halign = text.align_center, bgcolor = cvmCond_15m ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 4, 15, "POCMom", text_halign = text.align_center, bgcolor = pocCond_15m ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 4, 16, "Fractals", text_halign = text.align_center, bgcolor = mtCond_15m ? color.green : color.red, text_color = color.black, text_size = size.small)
    table.cell(tbl, 4, 17, str.tostring(100*(math.round(((d15m/17)+1)/2,2)))+'/100', text_halign = text.align_center, bgcolor = d15m>0 ? color.green : color.red, text_color = color.black, text_size = size.small)



plot(ta.ema(close,10),color=color.lime,linewidth=1)
plot(ta.ema(close,20),color=color.yellow,linewidth=1)
plot(ta.ema(close,50),color=color.orange,linewidth=1)
plot(ta.ema(close,100),color=color.red,linewidth=1)
plot(ta.ema(close,200),color=color.purple,linewidth=1)












// Join our channel for more free tools: https://t.me/simpleforextools














var float trendSum = 0

// Function to call built-in supertrend and calculate contribution to trendSum
calculateTrendContribution(periods, multiplier) =>
    [supertrend, direction] = ta.supertrend(multiplier, periods)
    direction * periods

// Reset trendSum at the beginning of each session or conditionally, if needed
trendSum := 0

// Calculate trend contributions for different settings
trendSum += calculateTrendContribution(6, 1)
trendSum += calculateTrendContribution(6, 2)
trendSum += calculateTrendContribution(6, 3)
trendSum += calculateTrendContribution(7, 1)
trendSum += calculateTrendContribution(7, 2)
trendSum += calculateTrendContribution(7, 3)
trendSum += calculateTrendContribution(8, 1)
trendSum += calculateTrendContribution(8, 2)
trendSum += calculateTrendContribution(8, 3)
trendSum += calculateTrendContribution(9, 1)
trendSum += calculateTrendContribution(9, 2)
trendSum += calculateTrendContribution(9, 3)
trendSum += calculateTrendContribution(10, 1)
trendSum += calculateTrendContribution(10, 2)
trendSum += calculateTrendContribution(10, 3)
trendSum += calculateTrendContribution(11, 1)
trendSum += calculateTrendContribution(11, 2)
trendSum += calculateTrendContribution(11, 3)
trendSum += calculateTrendContribution(12, 1)
trendSum += calculateTrendContribution(12, 2)
trendSum += calculateTrendContribution(12, 3)
trendSum += calculateTrendContribution(13, 1)
trendSum += calculateTrendContribution(13, 2)
trendSum += calculateTrendContribution(13, 3)
trendSum += calculateTrendContribution(14, 1)
trendSum += calculateTrendContribution(14, 2)
trendSum += calculateTrendContribution(14, 3)
rating10 = calculateTrendContribution(14, 3) + calculateTrendContribution(14, 2) + calculateTrendContribution(14, 1)

rating = trendSum
rsii = ta.rsi(rating, 21)
rsima = ta.ema(rsii, 14)


isCurrentRangeSmaller() =>
    srcHigh = high
    srcLow = low
    length = 20
    rangeRatio = (srcHigh - srcLow) / srcLow
    avgRangeRatio = math.sum(rangeRatio, length) / length
    rangeRatio < avgRangeRatio


rsip = ta.rsi(close, 21)
rsipma = ta.ema(rsip, 14)
bullBound = 50 - ag * 3 + 10
bearBound = 50 + ag * 3 - 10
[macdLine5, signalLine5, histLine5] = ta.macd(ta.sma(volume,33)-ta.sma(volume,100), 12, 26, 9)
condtrend = ta.ema(rating, 3) > ta.ema(rating, 5) and ta.ema(rating, 5) > ta.ema(rating, 8)
cond = condtrend and rsii > rsima and isCurrentRangeSmaller() and rating < 0 and rsip < bullBound and histLine5>0



cond2trend = ta.ema(rating, 3) < ta.ema(rating, 5) and ta.ema(rating, 5) < ta.ema(rating, 8)
cond2 = cond2trend and rsii < rsima and isCurrentRangeSmaller() and rating > 0 and rsip > bearBound  and histLine5>0
plotshape(cond and not cond[1], color=color.blue, style=shape.triangleup, size=size.normal, location=location.belowbar,text='ST Reversal')
plotshape(cond2 and not cond2[1], color=color.purple, style=shape.triangledown, size=size.normal, location=location.abovebar,text='ST Reversal')


import DevLucem/Divergence/1 as divLib

// Input for Fractal Depth
depth = 15

// Main Price Source

src=close

// Calculate indicators
rsi = ta.rsi(src, 14)
[macdLine, signalLine, _] = ta.macd(src, 12, 26, 9)
stochK = ta.stoch(close, high, low, 14)
obv = ta.obv
mfi = ta.mfi(src, 14)
adLine = ta.accdist

// Calculate divergences for each indicator

// RSI Divergence
[regBullRsi, hidBullRsi] = divLib.bullish(rsi, low, depth)
[regBearRsi, hidBearRsi] = divLib.bearish(rsi, high, depth)

// MACD Divergence
[regBullMacd, hidBullMacd] = divLib.bullish(macdLine, low, depth)
[regBearMacd, hidBearMacd] = divLib.bearish(macdLine, high, depth)

// Stochastic Divergence
[regBullStoch, hidBullStoch] = divLib.bullish(stochK, low, depth)
[regBearStoch, hidBearStoch] = divLib.bearish(stochK, high, depth)

// OBV Divergence
[regBullObv, hidBullObv] = divLib.bullish(obv, low, depth)
[regBearObv, hidBearObv] = divLib.bearish(obv, high, depth)

// MFI Divergence
[regBullMfi, hidBullMfi] = divLib.bullish(mfi, low, depth)
[regBearMfi, hidBearMfi] = divLib.bearish(mfi, high, depth)

// A/D Line Divergence
[regBullAd, hidBullAd] = divLib.bullish(adLine, low, depth)
[regBearAd, hidBearAd] = divLib.bearish(adLine, high, depth)


// RSI Signals
plotshape(regBullRsi, title="RSI Regular Bullish", location=location.belowbar, color=color.green, style=shape.triangleup, size=size.small, text="RSI Div")
plotshape(regBearRsi, title="RSI Regular Bearish", location=location.abovebar, color=color.red, style=shape.triangledown, size=size.small, text="RSI Div")

// MACD Signals
plotshape(regBullMacd, title="MACD Regular Bullish", location=location.belowbar, color=color.green, style=shape.triangleup, size=size.small, text="MACD Div")
plotshape(regBearMacd, title="MACD Regular Bearish", location=location.abovebar, color=color.red, style=shape.triangledown, size=size.small, text="MACD Div")

// Stochastic Signals
plotshape(regBullStoch, title="Stochastic Regular Bullish", location=location.belowbar, color=color.green, style=shape.triangleup, size=size.small, text="Stoch Div")
plotshape(regBearStoch, title="Stochastic Regular Bearish", location=location.abovebar, color=color.red, style=shape.triangledown, size=size.small, text="Stoch Div")

// OBV Signals
plotshape(regBullObv, title="OBV Regular Bullish", location=location.belowbar, color=color.green, style=shape.triangleup, size=size.small, text="OBV Div")
plotshape(regBearObv, title="OBV Regular Bearish", location=location.abovebar, color=color.red, style=shape.triangledown, size=size.small, text="OBV Div")

// MFI Signals
plotshape(regBullMfi, title="MFI Regular Bullish", location=location.belowbar, color=color.green, style=shape.triangleup, size=size.small, text="MFI Div")
plotshape(regBearMfi, title="MFI Regular Bearish", location=location.abovebar, color=color.red, style=shape.triangledown, size=size.small, text="MFI Div")

// A/D Line Signals
plotshape(regBullAd, title="A/D Line Regular Bullish", location=location.belowbar, color=color.green, style=shape.triangleup, size=size.small, text="A/D Div")
plotshape(regBearAd, title="A/D Line Regular Bearish", location=location.abovebar, color=color.red, style=shape.triangledown, size=size.small, text="A/D Div")


import HoanGhetti/SimpleTrendlines/5 as tl

input_len = 10
pivotLow = fixnan(ta.pivotlow(input_len, input_len))

xAxis = ta.valuewhen(ta.change(pivotLow), bar_index, 0) - ta.valuewhen(ta.change(pivotLow), bar_index, 1)
prevPivot = ta.valuewhen(ta.change(pivotLow), pivotLow, 1)
pivotCondition = ta.change(pivotLow) and pivotLow > prevPivot 

plData = tl.new(x_axis = xAxis, offset = input_len)
plData.drawLine(pivotCondition, prevPivot, pivotLow)
plData.drawTrendline(close > 0)

plData.lines.trendline.set_style(line.style_dashed)
plData.lines.trendline.set_color(plData.values.slope>0?color.green:color.red)
plData.lines.trendline.set_width(2)
plData.lines.startline.set_width(2)



pivotHigh = fixnan(ta.pivothigh(input_len, input_len))

xAxis1 = ta.valuewhen(ta.change(pivotHigh), bar_index, 0) - ta.valuewhen(ta.change(pivotHigh), bar_index, 1)
prevPivot1 = ta.valuewhen(ta.change(pivotHigh),pivotHigh, 1)
pivotCondition1 = ta.change(pivotHigh) and pivotHigh < prevPivot1

plData1 = tl.new(x_axis = xAxis1, offset = input_len)
plData1.drawLine(pivotCondition1, prevPivot1, pivotHigh)
plData1.drawTrendline(close > 0)

plData.lines.trendline.set_style(line.style_dashed)
plData.lines.trendline.set_color(plData.values.slope>0?color.green:color.red)
plData.lines.trendline.set_width(2)
plData.lines.startline.set_width(2)

plData1.lines.trendline.set_style(line.style_dashed)
plData1.lines.trendline.set_color(plData1.values.slope>0?color.green:color.red)
plData1.lines.trendline.set_width(2)
plData1.lines.startline.set_width(2)




kama(src,Length)=>
    xPrice = src
    xvnoise = math.abs(xPrice - xPrice[1])
    nAMA = 0.0
    nfastend = 0.666
    nslowend = 0.0645
    nsignal = math.abs(xPrice - xPrice[Length])
    nnoise = math.sum(xvnoise, Length)
    nefratio = nnoise != 0? nsignal / nnoise: 0
    nsmooth = math.pow(nefratio * (nfastend - nslowend) + nslowend, 2) 
    nAMA := nz(nAMA[1]) + nsmooth * (xPrice - nz(nAMA[1]))
    nAMA



src2 = ohlc4

ma05  =  kama(src2, 05) 
ma10  =  kama(src2, 10) 
ma15  =  kama(src2, 15) 
ma20  =  kama(src2, 20) 
ma25  =  kama(src2, 25) 
ma30  = kama(src2, 30) 
ma35  =  kama(src2, 35) 
ma40  =  kama(src2, 40) 
ma45  =  kama(src2, 45) 
ma50  =  kama(src2, 50) 
ma55  =  kama(src2, 55) 
ma60  = kama(src2, 60) 
ma65  =  kama(src2, 65) 
ma70  =  kama(src2, 70) 
ma75  =  kama(src2, 75) 
ma80  = kama(src2, 80) 
ma85  = kama(src2, 85) 
ma90  = kama(src2, 90) 
ma100 =  kama(src2, 100)

totalDistance = ((ma05-ma10)/ma10 + (ma10-ma15)/ma15 + (ma15-ma20)/ma20 + (ma20-ma25)/ma25 +
                 (ma25-ma30)/ma30 + (ma30-ma35)/ma35 + (ma35-ma40)/ma40 + (ma40-ma45)/ma45 +
                 (ma45-ma50)/ma50 + (ma50-ma55)/ma55 + (ma55-ma60)/ma60 + (ma60-ma65)/ma65 +
                 (ma65-ma70)/ma70 + (ma70-ma75)/ma75 + (ma75-ma80)/ma80 + (ma80-ma85)/ma85 +
                 (ma85-ma90)/ma90 + (ma90-ma100)/ma100)/18

bgcolor(totalDistance>0?color.rgb(0,150,0,50):color.rgb(150,0,0,50))

// ==========================================================================================
